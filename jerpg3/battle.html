<!doctype html>
<html>

<head>

<script>

const INTERVAL = 100;

class BattleTile {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.color = "rgb(0,200,0)";
        this.units = []; //[occupied unit, travelling unit]
    }

    addUnit(unit) {
        this.units.push(unit);
    }

    removeUnit(unit) {
        this.units = this.units.filter(function(u) {
            return u.id != unit.id;
        });
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x * 60, this.y * 60, 59, 59);
    }
}

class BattleMap {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        //this.units = [];
        this.tile = [];
        for (var x=0; x<width; x++) {
            this.tile[x] = [];
            for (var y=0; y<height; y++) {
                this.tile[x][y] = new BattleTile(x, y);
            }
        }
    }

    update() {

    }

    draw(ctx) {
        ctx.fillStyle = "rgb(0,0,0)";
        ctx.fillRect(0,0,640,480);
        for (var x=0; x<this.width; x++) {
            for (var y=0; y<this.height; y++) {
                this.tile[x][y].draw(ctx);
            }
        }

        if (this.moveList) {
            ctx.fillStyle = "rgba(255,0,255,0.5)";
            this.moveList.forEach(function(m) {
                ctx.fillRect(m.x * 60, m.y * 60, 59, 59);
            });
        }
    }

    getUnit(x, y) {
        if (this.tile[x] && this.tile[x][y]) {
            return this.tile[x][y].units[0];
        }
    }

    addUnit(unit) {
        //this.units.push(unit);
        this.tile[unit.x][unit.y].addUnit(unit);
    }

    moveUnit(unit, x, y) {
        this.tile[unit.x][unit.y].removeUnit(unit);
        unit.x = x;
        unit.y = y;
        this.tile[x][y].addUnit(unit);
    }
}

function getBestMove(map, unit) {
    var moveList = getMoveList(map, unit);
    
    var bestMove = moveList.sort(function(a, b) {
        return b.steps - a.steps;
    })[0];

    return bestMove;
}

function createBinaryMap(map, width, height) {
    var bmap = [];
    for (var x=0; x<width; x++) {
        bmap[x] = [];
        for (var y=0; y<height; y++) {
            bmap[x][y] = 0;
        }
    }
    return bmap;
}

function getMapNodes(map, startX, startY, team) {
    var binaryMap = createBinaryMap(map, 8, 8);
    binaryMap[startX][startY] = 1;

    var i = 0, steps = 0;
    var xList = [0, -1, 0, 1];
    var yList = [-1, 0, 1, 0];

    var nodeList = [{
        x: startX,
        y: startY,
        parent: null,
        steps: 0
    }];

    while (i < nodeList.length) {
        for (var j=0; j<4; j++) {

            var x = nodeList[i].x + xList[j];
            var y = nodeList[i].y + yList[j];

            //if node is off the map
            if (x < 0 || y < 0 || x >= map.width || y >= map.height) {
                continue;
            }

            //if node has already been visited
            if (binaryMap[x][y] === 1) {
                continue;
            }

            var unit = map.tile[x][y].units[0];

            //if unit exists on node and is enemy
            if (unit && unit.team != team) {
                //if enemy is not dead
                if (unit.status != "dead") {
                    continue;
                }
            }
            
            nodeList.push({
                x: x,
                y: y,
                parent: nodeList[i],
                steps: nodeList[i].steps + 1
            });
            binaryMap[x][y] = 1;
        }
        i++;
    }

    return nodeList;
}

function getPath(move) {
    var path = [];

    var node = move;

    while (node) {
        path.push(node);
        node = node.parent;
    }

    return path.reverse();
}

function createSpread(x, y, spread) {
    var newspread = [];
    spread.forEach(function(s) {
        newspread.push({
            x: s[0] + x,
            y: s[1] + y
        });
    });
    return newspread;
}

function createDiamond(x, y, range, center) {
    var diamond = [];
    for (var i=-range; i<=range; i++) {
        for (var j=-range; j<=range; j++) {
            if (!center && i == j) {
                continue;
            }
            else if (Math.abs(i) + Math.abs(j) <= range) {
                diamond.push({
                    x: i + x,
                    y: j + y
                });
            }
        }
    }
    return diamond;
}

//todo: targets can also be tiles
function getTargetList(map, unit, move, spread) {
    var targetList = [];
    spread.forEach(function(s) {
        var mapunit = map.getUnit(s.x, s.y);
        if (mapunit && mapunit.id != unit.id) { //do not target self based on map location
            targetList.push(mapunit);
        }
        if (s.x == move.x && s.y == move.y) { //only target self in new move location
            targetList.push(unit);
        }
    });
    return targetList;
}

//gets list of possible move locations
function getMoveList(map, unit) {
    var moveList = getMapNodes(map, unit.x, unit.y, unit.team);
    
    //filter out nodes that are occupied by any unit besides self
    moveList = moveList.filter(function(n) {
        var u = map.tile[n.x][n.y].units[0];
        return !u || u.id == unit.id;
    });

    return moveList;
}

//get the best action for a particular move case
function getBestAction(map, unit, move) {
    var actionList = [];

    unit.actionList.forEach(function(a) {
        var diamond = createDiamond(move.x, move.y, a.range, false);

        diamond.forEach(function(d) {
            var spread = createSpread(d.x, d.y, a.spread);
            var targetList = getTargetList(map, unit, move, spread);
            if (targetList.length > 0) {
                actionList.push(new BattleAction(unit, move, a, d.x, d.y, spread, targetList));
            }
        });
    });

    //calculate score here

    actionList.sort(function(a, b) {
        return b.score - a.score;
    });

    return actionList[0];
}

function getBestActionMove(map, unit) {
    var moveList = getMoveList(map, unit);
    map.moveList = moveList;
    var moveActionList = [];
    var bestActionMove;

    if (moveList.length == 0) {
        console.error("moveList cannot be 0!");
    }

    moveList.forEach(function(m) {
        moveActionList.push(getBestAction(map, unit, m));
    });

    moveActionList.sort(function(a, b) {
        return b.score - a.score;
    });

    bestActionMove = moveActionList[0];

    return bestActionMove;
}

class BattleUnit {
    constructor(team) {
        this.id = Math.floor(Math.random() * 100000000);
        this.team = team;
        this.x = Math.floor(Math.random() * 8);
        this.y = Math.floor(Math.random() * 8);
        this.color = ["rgb(255,0,0)","rgb(0,255,0)"][team];
        this.sprite = Math.floor(Math.random() * 90) + 10;
        this.at = 0;
        this.hp = Math.floor(Math.random() * 25) + 50;
        this.agl = Math.floor(Math.random() * 5) + 1;
        this.actionList = [{ "name":"Bash", "range":1, "spread":[[0,0]] }];
        this.state = "";
        this.moved = false;
        this.acted = false;
    }

    update() {

    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.textBaseline = "top";
        ctx.font = "48px Arial";
        ctx.fillText(this.sprite, this.x * 60, this.y * 60);
    }

    applyDamage() {
        this.hp -= 1;
        console.log(this.sprite + " was damaged for " + 1 + " hp.");
    }

    done() {
        this.moved = false;
        this.acted = false;
    }

    toString() {
        return this.sprite + "(hp:" + this.hp + ")";
    }
}

class BattleParty {
    constructor(team) {
        this.units = [];
        this.team = team;
        for (var i=0; i<5; i++) {
            this.units.push(new BattleUnit(team));
        }
        
    }
}

class BattleMove {
    constructor(unit, move) {
        this.unit = unit;
        this.move = move;
        this.path = getPath(move);
        this.ct = 0;
    }

    invoke(map) {
        /*
        if (!this.path) {
            var mapList = getMapNodes(map, this.unit.x, this.unit.y, this.unit.team);
            var bestMove = getBestMove(map, this.unit, mapList);
            this.path = getPath([bestMove], bestMove.x, bestMove.y);
        }
        */

        var nextMove = this.path.shift();

        if (nextMove) {
            map.moveUnit(this.unit, nextMove.x, nextMove.y);
            return this;
        }
        else {
            this.done();
            return false;
        }
    }

    done() {
        if (this.move.steps > 0) {
            this.unit.at -= 40;
        }
        this.unit.moved = true;
    }

    toString() {
        return this.unit.sprite + " MOVE! CT: " + this.ct;
    }
}

class BattleAction {
    constructor(unit, move, action, x, y, spread, targetList) {
        this.unit = unit;
        this.move = move; //where the unit must be in order to complete the action
        this.action = action;
        this.x = x;
        this.y = y;
        this.spread = spread;
        this.targetList = targetList;
        this.score = targetList.length;
        this.ct = Math.floor(Math.random() * 50) + 1;

        //console.log("unit no. " + unit.sprite + " wants to move to x: " + move.x + "," + move.y + " and attack unit no. " + targetList[0].sprite);
    }

    invoke(map) {
        console.log(this.unit.toString() + " invoked an action.");

        this.targetList.forEach(function(t) {
            t.applyDamage();
        });
        this.unit.state = "";
        this.unit.at -= 60;
        this.unit.acted = true;
    }

    toString() {
        return this.unit.sprite + " ACTION! CT: " + this.ct;
    }
}

class ActionMove {
    constructor(unit, first, second) {
        this.unit = unit;
        this.list = [first, second];
        this.score = 0;
    }

    //invoke(map) {
    //    this.shift(0).invoke(map);
    //}
}

class Battle {
    constructor(party1, party2) {
        this.map = new BattleMap(8, 8);
        this.units = [];
        this.addUnits(party1.units);
        this.addUnits(party2.units);
        this.queue = [];
        this.log = "";
        this.nextAction = null;
    }

    update() {
        this.log = "";

        if (!this.nextAction) {
            this.nextAction = this.getNextAction();
        }

        if (this.nextAction) {
            this.nextAction = this.nextAction.invoke(this.map);
        }

        document.getElementById("log").innerHTML = this.log;

        /*
        this.map.update();

        this.units.forEach(function(u) {
            u.update();
        });
        */
    }

    draw(ctx) {
        this.map.draw(ctx);

        this.units.forEach(function(u) {
            u.draw(ctx);
        });
    }

    addUnits(units) {
        this.units = this.units.concat(units);
        units.forEach(function(u) {
            this.map.addUnit(u);
        }, this);
    }

    getNextActiveUnit() {
        var nextUnit;

        this.units.forEach(function(u) {
            if (u.at > 100) {
                u.at = 100;
                nextUnit = u;
            }
        });

        if (nextUnit) {
            return nextUnit;
        }

        var availableUnits = this.units.filter(function(u) {
            return u.state == ""; //also check if alive
        });

        if (availableUnits.length == 0) {
            return null;
        }

        while (!nextUnit) {
            availableUnits.forEach(function(u) {
                u.at += u.agl;
                if (u.at >= 100) {
                    nextUnit = u;
                }
            });
        }

        return nextUnit;
    }

    getNextAction() {
        var nextAction;

        if (this.queue.length > 0) {
            this.queue.forEach(function(q) {
                q.ct = q.ct - 1;
            }, this);

            this.queue.sort(function(a,b) {
                return a.ct - b.ct;
            });

            this.queue.forEach(function(q) {
                this.log += q.toString() + "\n";
            }, this);

            if (this.queue[0].ct <= 0) {
                nextAction = this.queue.shift();
            }
        }

        if (!nextAction) {
            var nextUnit = this.getNextActiveUnit();
            if (nextUnit) {
                if (nextUnit.acted == false && nextUnit.moved == false) {
                    var bestActionMove = getBestActionMove(this.map, nextUnit);
                    if (bestActionMove.move.x == nextUnit.x && bestActionMove.move.y == nextUnit.y) { //no move
                        this.queueActionMove(bestActionMove);
                    }
                    else { //if unit has to move to carry out action
                        this.queueActionMove(new BattleMove(nextUnit, bestActionMove.move))
                    }
                }
                else if (nextUnit.acted == true && nextUnit.moved == false) {
                    var bestMove = getBestMove(map, nextUnit);
                    this.queueActionMove(bestMove);
                }
                else if (nextUnit.acted == false && nextUnit.moved == true) {
                    var bestAction = getBestAction(map, nextUnit, {x: nextUnit.x, y: nextUnit.y});
                    this.queueActionMove(bestAction);
                }
                else {
                    nextUnit.done();
                    nextAction = null;
                }
            }
        }

        return nextAction;
    }

    queueActionMove(actionMove) {
        actionMove.unit.state = "charging";
        this.queue.push(actionMove);
    }
}

var canvas, context, battle, lastTick;

function loop() {

    if (Date.now() > lastTick + INTERVAL) {
        battle.update();
        draw();
        lastTick = Date.now();
    }

    requestAnimationFrame(loop);
}

function draw() {
    battle.draw(context);
}

window.onload = function() {
    canvas = document.getElementById("canvas");
    context = canvas.getContext("2d");

    var party1 = new BattleParty(0);
    var party2 = new BattleParty(1);

    battle = new Battle(party1, party2);
    lastTick = 0;

    loop();
};

</script>

</head>

<body>

<canvas id="canvas" width="640" height="480"></canvas>

<textarea id="log" rows="12" cols="50"></textarea>

</body>

</html>