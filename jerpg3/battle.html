<!doctype html>
<html>

<head>

<script>

class BattleTile {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.color = "rgb(0,200,0)";
        this.unit = null;
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x * 60, this.y * 60, 59, 59);
    }
}

class BattleMap {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.units = [];
        this.tile = [];
        for (var x=0; x<width; x++) {
            this.tile[x] = [];
            for (var y=0; y<height; y++) {
                this.tile[x][y] = new BattleTile(x, y);
            }
        }
    }

    update() {

    }

    draw(ctx) {
        ctx.fillStyle = "rgb(0,0,0)";
        ctx.fillRect(0,0,640,480);
        for (var x=0; x<this.width; x++) {
            for (var y=0; y<this.height; y++) {
                this.tile[x][y].draw(ctx);
            }
        }
    }

    getUnit(x, y) {
        if (this.tile[x] && this.tile[x][y]) {
            return this.tile[x][y].unit;
        }
    }

    addUnit(unit) {
        this.units.push(unit);
        this.tile[unit.x][unit.y].unit = unit;
    }

    moveUnit(unit, path) {
        this.tile[unit.x][unit.y].unit = null;
        unit.x = path[0].x;
        unit.y = path[0].y;
        this.tile[unit.x][unit.y].unit = unit;
    }
}

function getBestMove(map) {
    var moveList = this.getMoveList(map);
    
    var bestMove = moveList.sort(function(a, b) {
        return b.score - a.score;
    })[0];

    return new BattleMove(this, bestMove);
}

function getMapNodes(map, startX, startY, range) {
    var steps = 0;
    var nodeList = [new Node(startX, startY, steps)];
    var i = 0;
    while (i < nodeList.length) {

    }
    return nodeList;
}

function getPath(map, startX, startY, range) {
    var path = [];

    path.push({
        
    });

    return path;
}
    
function getAllPaths(map, startX, startY, range) {
    var paths = [];
    //also record the light map
    //also record whether or not the end is reachable
    


    paths.push({
        path: getPath(map, startX, startY, range),
        score: range //greater range -> path finding over multiple turns
    });



    return paths;
}

function createSpread(x, y, spread) {
    var newspread = [];
    spread.forEach(function(s) {
        newspread.push({
            x: s[0] + x,
            y: s[1] + y
        });
    });
    return newspread;
}

function createDiamond(x, y, range, center) {
    var diamond = [];
    for (var i=-range; i<=range; i++) {
        for (var j=-range; j<=range; j++) {
            if (!center && i == j) {
                continue;
            }
            else if (Math.abs(i) + Math.abs(j) <= range) {
                diamond.push({
                    x: i + x,
                    y: j + y
                });
            }
        }
    }
    return diamond;
}

//todo: targets can also be tiles
function getTargetList(map, spread) {
    var targetList = [];
    spread.forEach(function(s) {
        var unit = map.getUnit(s.x, s.y);
        if (unit) {
            targetList.push(unit);
        }
    });
    return targetList;
}

function getMoveList(map, unit) {
    var moveList = [];
    for (var x=0; x<8; x++) {
        for (var y=0; y<8; y++) {
            moveList.push({
                start: {
                    x: unit.x,
                    y: unit.y
                },
                end: {
                    x: x,
                    y: y
                },
                path: [
                    {
                        x: x,
                        y: y
                    }
                ]
            });
        }
    }
    return moveList;
}

//get the best action for a particular move case
function getBestAction(map, unit, move) {
    var actionList = [];

    unit.actionList.forEach(function(a) {
        var diamond = createDiamond(unit.x + move.end.x, unit.y + move.end.y, a.range, false);

        diamond.forEach(function(d) {
            var spread = createSpread(d.x, d.y, a.spread);
            var targetList = getTargetList(map, spread);
            actionList.push(new BattleAction(unit, move, a, d.x, d.y, spread, targetList));
        });
    });

    actionList.sort(function(a, b) {
        return b.score - a.score;
    });

    return actionList[0];
}

function getBestActionMove(map, unit) {
    var moveList = getMoveList(map, unit);
    var moveActionList = [];

    moveList.forEach(function(m) {
        moveActionList.push(getBestAction(map, unit, m));
    });

    moveActionList.sort(function(a, b) {
        return b.score - a.score;
    });

    var bestActionMove = moveActionList[0];

    if (bestActionMove.move.path.length > 0) { //if the unit must move first
        return new ActionMove(unit, new BattleMove(unit, bestActionMove.move), bestActionMove);
    }
    else {
        return new ActionMove(unit, bestActionMove, new BattleMove(unit, null));
    }
}

class BattleUnit {
    constructor(color) {
        this.x = Math.floor(Math.random() * 8);
        this.y = Math.floor(Math.random() * 8);
        this.color = color;
        this.sprite = Math.floor(Math.random() * 90) + 10;
        this.at = 0;
        this.hp = Math.floor(Math.random() * 25) + 50;
        this.agl = Math.floor(Math.random() * 5) + 1;
        this.actionmove = null;
        this.actionList = [{ "name":"Bash", "range":1, "spread":[[0,0]] }];
        this.state = "";
    }

    update() {

    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.textBaseline = "top";
        ctx.font = "48px Arial";
        ctx.fillText(this.sprite, this.x * 60, this.y * 60);
    }

    applyDamage() {
        this.hp -= 1;
        console.log(this.sprite + " was damaged for " + 1 + " hp.");
    }

    done() {
        this.at = 0;
        this.actionmove = null;
    }
}

class BattleParty {
    constructor(color) {
        this.units = [];
        this.color = color;
        for (var i=0; i<5; i++) {
            this.units.push(new BattleUnit(color));
        }
        
    }
}

class BattleMove {
    constructor(unit, move) {
        this.unit = unit;
        this.move = move;
        this.ct = 0;
    }

    invoke(map) {
        if (!this.move) {
            this.move = getBestMove(map, this.unit);
        }

        map.moveUnit(this.unit, this.move.path);
        this.unit.at -= 40;
    }

    toString() {
        return this.unit.sprite + " MOVE! CT: " + this.ct;
    }
}

class BattleAction {
    constructor(unit, move, action, x, y, spread, targetList) {
        this.unit = unit;
        this.move = move;
        this.action = action;
        this.x = x;
        this.y = y;
        this.spread = spread;
        this.targetList = targetList;
        this.score = targetList.length;
        this.ct = Math.floor(Math.random() * 100) + 1;
    }

    invoke(map) {
        this.targetList.forEach(function(t) {
            t.applyDamage();
        });
        this.unit.state = "";
        this.unit.at -= 60;
    }

    toString() {
        return this.unit.sprite + " ACTION! CT: " + this.ct;
    }
}

class ActionMove {
    constructor(unit, first, second) {
        this.unit = unit;
        this.list = [first, second];
        this.score = 0;
    }

    //invoke(map) {
    //    this.shift(0).invoke(map);
    //}
}

class Battle {
    constructor(party1, party2) {
        this.map = new BattleMap(8, 8);
        this.units = [];
        this.addUnits(party1.units);
        this.addUnits(party2.units);
        this.queue = [];
        this.log = "";
        this.nextAction = null;
    }

    update() {
        this.log = "";

        if (!this.nextAction) {
            this.nextAction = this.getNextAction();
        }

        if (this.nextAction) {
            this.nextAction.invoke(this.map); //update?
            this.nextAction = null;
        }

        document.getElementById("log").innerHTML = this.log;

        /*
        this.map.update();

        this.units.forEach(function(u) {
            u.update();
        });
        */
    }

    draw(ctx) {
        this.map.draw(ctx);

        this.units.forEach(function(u) {
            u.draw(ctx);
        });
    }

    addUnits(units) {
        this.units = this.units.concat(units);
        units.forEach(function(u) {
            this.map.addUnit(u);
        }, this);
    }

    getNextActiveUnit() {
        var nextUnit;

        this.units.forEach(function(u) {
            if (u.at > 100) {
                u.at = 100;
                nextUnit = u;
            }
        });

        if (nextUnit) {
            return nextUnit;
        }

        var availableUnits = this.units.filter(function(u) {
            return u.state == ""; //also check if alive
        });

        if (availableUnits.length == 0) {
            return null;
        }

        while (!nextUnit) {
            availableUnits.forEach(function(u) {
                u.at += u.agl;
                if (u.at >= 100) {
                    nextUnit = u;
                }
            });
        }

        return nextUnit;
    }

    getNextAction() {
        var nextAction;

        if (this.queue.length > 0) {
            this.queue.forEach(function(q) {
                q.ct = q.ct - 1;
            }, this);

            this.queue.sort(function(a,b) {
                return a.ct - b.ct;
            });

            this.queue.forEach(function(q) {
                this.log += q.toString() + "\n";
            }, this);

            if (this.queue[0].ct <= 0) {
                nextAction = this.queue.shift();
            }
        }

        if (!nextAction) {
            var nextUnit = this.getNextActiveUnit();
            if (nextUnit) {
                var actionMove = getBestActionMove(this.map, nextUnit);
                this.queueActionMove(actionMove.list[0]);
                this.queueActionMove(actionMove.list[1]);
            }
        }

        return nextAction;
    }

    queueActionMove(s) {
        s.unit.state = "charging";
        this.queue.push(s);
    }
}

var canvas, context, battle, lastTick;

function loop() {

    if (Date.now() > lastTick + 1000) {
        battle.update();
        draw();
        lastTick = Date.now();
    }

    requestAnimationFrame(loop);
}

function draw() {
    battle.draw(context);
}

window.onload = function() {
    canvas = document.getElementById("canvas");
    context = canvas.getContext("2d");

    var party1 = new BattleParty("rgb(255,0,0)");
    var party2 = new BattleParty("rgb(0,255,0)");

    battle = new Battle(party1, party2);
    lastTick = 0;

    loop();
};

</script>

</head>

<body>

<canvas id="canvas" width="640" height="480"></canvas>

<textarea id="log" rows="12" cols="50"></textarea>

</body>

</html>